# JAVA#4JVM

### Java Visual Machine

- 프로그램이 실행되는 플랫폼
- 운영체제용과 아키텍처용이 있다
- 운영체제와 애플리케이션 사이에 위치하면서 애플리케이션이 플랫폼에 상관없이 독립적으로 실행될 수 있도록 만들어준다. 
- 자바 프로그램은 javac을 이용해 바이트코드로 컴파일 → JVM에서 명령어들을 아키텍처와 운영체제용으로 해석

## 가비지 컬렉션(Garbage Collection)

### 메모리 할당

- 힙(heap) 영역
  - 애플리케이션에 접급할 수 있는 메모리의 메인 영역
  - new 키워드를 선언하면 힙영역에 메모리를 할당
- 개체를 할당할 때 메모리가 충분하지 않으면 JVM은 가비지 컬렉션을 이용해 힙에서 메모리를 재사용하려고 시도
  - 시도가 실패하면 OutOfMemoryError발생, JVM 종료
- 힙의 구분 - 제너레이션(generation)
  - 가비지 컬렉션에서 객체가 수집 대상에서 제외된다면 다른 제너레이션으로 이동
  - older, Eden, Survivor, Tenured
  - Metaspace
    - 이 제너레이션에 속한 객체들은 가비지 컬렉션에서 수집할 때 선택되지 않는다
    - 일반적으로 클래스 정의나 String 상수 같이 JVM에서 실행되는 데 필요한 불변(immutable) 상태가 포함

### 가비지 컬렉션

- 기존에 할당된 메모리를 재사용하는 매커니즘

- 대부분의 프로그래밍 언어(java, c#, ...)는 자동으로 실행

- c, c++ 같은 언어는 메모리 할당을 수동으로 직접 관리

- 컬렉션 알고리즘

  - mark-and-sweep

    1. 실행 중인 코드에서 참조하는 객체와 해당 객체에서 참조하는 것들 역시 확인해서 live로 표시

    2. 힙에 있는 각 객체들을 찾아다니며 live로 표시되지 않은 메모리 위치에 메모리를 할당할 수 있게 만든다
       - 이 과정 동안 JVM의 모든 스레드가 정지 : stop-the-world

  - Garbage First

- 컴패션(compaction)

  - live로 표시한 객체들을 다른 물리적인 메모리 위치로 옮김으로써 JVM이 stop-the-world인 동안 메모리 공간을 확보

## 메모리 튜닝

### 스택&힙

- 스택stack
  - 기본값, 객체의 참조, 메서드가 저장되는 위치
  - 스택에 있는 변수의 생애주기는 코드의 스코프(scope)에 영향을 받는다
    - 스코프
      - 일반적으로 메서드 호출이나 for문, while문 같은 코드에서 괄호로 구분해서 정의
      - 스코프의 실행이 종료되면 스코프 안에 선언된 변수들은 스택에서 제거
  - 재귀 메서드가 스스로를 너무 많이 호출하면 스택 메모리 영역이 가득차게 되고, StackOverflowError가 발생
    - 더이상 재귀 호출이 일어나지 않게 하는 초기조건(base case)으로 메서드 안의 상태를 지정하는 게 중요

### JVM의 힙 크기 지정

- JVM은 각각의 메모리 영역에 할당된 메모리의 크기를 지정할 수 있는 커맨드 라인 매개 변수 제공
  - -Xmx 크기
    - 최대 힙 크기를 지정
  - -Xms 크기
    - JVM에 할당할 초기 메모리를 지정
  - 두 매개변수가 같은 값으로 설저오디어 있으면 JVM은 실행할 때 모든 메모리를 할당하도록 운영체제에 요청
- -XX:Permsize, -XX:MaxPermSize
  - permanent(Metaspace) 제너레이션 용
  - 클래스와 string 상수를 많이 사용하거나 비 자바 프로그래밍 언어에서 동적인 클래스 정의를 많이 사용한다면 이 값을 설정할 수 있다