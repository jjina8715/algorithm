# OOP_원칙SOLID

### SRP: 단일 책임 원칙

- Single Responsibility Principle
- 객체는 오직 하나의 책임을 가져야 한다.(오직 하나의 변경 이유만을 가져야 한다)
- 클래스의 목적을 명확히 함
  - 구조가 난잡해지거나 수정 사항이 불필요하게 넓게 퍼지는 것을 예방
  -  기능을 명확히 분리
- 하나의 클래스가 두 가지 이상의 책임을 지니게 되면
  - 클래스의 목적이 모호해지고 
  - 기능을 수정할 때 영향을 받는 범위도 증가
  - 유지보수가 어려워진다
- 예
  - 데이터 매퍼, 패턴(DAO)

### OCP: 개방-폐쇄 원칙

- Open-Closed Principle
- 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.
  - 객체 기능의 확장을 허용하고 스스로의 변경은 피해야 한다.
- 예
  - 상속과 어댑터 클래스를 통한 클라이언트 크래스 접속
  - 컴파일러, POSIX 표준

### LSP: 리스코프 치환 원칙

- Liskov Substitution Principle
- 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다.
  - 부모 클래스가 들어갈 자리에 자신 클래스를 넣어도 계획대로 잘 작동해야 한다는 것
- 지키지 않으면 부모 클래스 본래의 의미가 변해서 is-a 관계가 망가져 다형성을 지킬 수 없게 된다

### ISP: 인터페이스 분리 원칙

- Interface Segregation Principle
- 클라이언트에서 사용하지 않는 메서드는 사용해선 안된다.
  - 인터페이스를 다시 (적당히) 작게 나누어 만든다
- OCP와는 비슷한 듯 하지만 다른 원칙이다. 다만 ISP를 잘 지키면 OCP도 잘 지켜질 확률이 증가
- 예
  - 파일 입력은 InputInterface, 파일 출력은 OutputInterface
  - 공유 repository 패턴

### DIP: 의존성 역전 원칙

- Dependency Inversion Principle
- 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다
  - 일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수 가능
- 예
  - 이벤트 드리븐, 콜백, JMS, 통신 프로그래밍 모델